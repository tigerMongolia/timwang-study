### 一. HashMap（JDK-1.8）

#### 0. 哈希表



#### 1. 简介

HashMap采用key/value存储结构，每个key对应唯一的value，查询和修改的速度都很快，能达到O(1)的平均时间复杂度。它是非线程安全的，且不保证元素存储的顺序；

#### 2. 继承体系

<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfueavdpswj30bs06eq2u.jpg" style="zoom:100%;float:left" />

HashMap实现了Cloneable，可以被克隆。

HashMap实现了Serializable，可以被序列化。

HashMap继承自AbstractMap，实现了Map接口，具有Map的所有功能。

#### 3.HashMap存储结构

<img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gfuecwf0y0j30r20hxgmm.jpg" alt="image-20200205095809050" style="zoom:50%;float:left" />

##### 3.1 结构说明

在Java中，HashMap的实现采用了（数组 + 链表 + 红黑树）的复杂结构，数组的一个元素又称作桶。

1. 在添加元素时，会根据hash值算出元素在数组中的位置，如果该位置没有元素，则直接把元素放置在此处，如果该位置有元素了，则把元素以链表的形式放置在链表的尾部。

2. 当一个链表的元素个数达到一定的数量（且数组的长度达到一定的长度）后，则把链表转化为红黑树，从而提高效率。

3. 数组的查询效率为O(1)，链表的查询效率是O(k)，红黑树的查询效率是O(log k)，k为桶中的元素个数，所以当元素数量非常多的时候，转化为红黑树能极大地提高效率。

##### 3.2 为什么会转换成红黑树？

1. 这个是在java8中做的优化，目的是当hash碰撞严重的时候，链表过长，通过树可以提升查找效率（链表是n ,树是logn），之所以用红黑树，是因为红黑树是平衡树，平衡树的特点是叶子节点的高度差不会大于1，这样可以避免树在极端情况下退化成链表，导致优化了等于白给。

##### 3.3 为什么不全部链表转红黑树

1. 第一个是链表的结构比红黑树简单，构造红黑树要比构造链表复杂，所以在链表的节点不多的情况下，从整体的性能看来，
   数组+链表+红黑树的结构不一定比数组+链表的结构性能高。
2. 第二个是HashMap频繁的resize（扩容），扩容的时候需要重新计算节点的索引位置，也就是会将红黑树进行拆分和重组其实
   这是很复杂的，这里涉及到红黑树的着色和旋转，这又是一个比链表结构耗时的操作，所以为链表树化设置一个阀值是非常有必要的。

#### 4. 源码解析

##### 4.0 注释

1. 允许NULL值，NULL键
2. 不要轻易改变负载因子，负载因子过高会导致链表过长，查找键值对时间复杂度就会增高，负载因子过低会导致hash桶的 数量过多，空间复杂度会增高
3. Hash表每次会扩容长度为以前的2倍
4. HashMap是多线程不安全的，我在JDK1.7进行多线程put操作，之后遍历，直接死循环，CPU飙到100%，在JDK 1.8中进行多线程操作会出现节点和value值丢失，为什么JDK1.7与JDK1.8多线程操作会出现很大不同，是因为JDK 1.8的作者对resize方法进行了优化不会产生链表闭环。这也是本章的重点之一，具体的细节大家可以去查阅资料。这里我就不解释太多了
5. 尽量设置HashMap的初始容量，尤其在数据量大的时候，防止多次resize

##### 4.1 类常量

```Java
//默认hash桶初始长度16
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; 

//hash表最大容量2的30次幂
static final int MAXIMUM_CAPACITY = 1 << 30;

//默认负载因子 0.75
static final float DEFAULT_LOAD_FACTOR = 0.75f;

//链表的数量大于等于8个并且桶的数量大于等于64时链表树化 
static final int TREEIFY_THRESHOLD = 8;

//hash表某个节点链表的数量小于等于6时树拆分
static final int UNTREEIFY_THRESHOLD = 6;

//树化时最小桶的数量
static final int MIN_TREEIFY_CAPACITY = 64;
```

##### 4.2 实例变量

```java
//hash桶
transient Node<K,V>[] table;                         

//键值对的数量
transient int size;

//HashMap结构修改的次数
transient int modCount;

//扩容的阀值，当键值对的数量超过这个阀值会产生扩容
int threshold;

//负载因子
final float loadFactor;
```

##### 4.3 构造方法

```java
public HashMap(int initialCapacity, float loadFactor) {                                                                   
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal initial capacity: " +
                                           initialCapacity);
    if (initialCapacity > MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    if (loadFactor <= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException("Illegal load factor: " + loadFactor);
    this.loadFactor = loadFactor;
    this.threshold = tableSizeFor(initialCapacity);
}

public HashMap(int initialCapacity) {
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
}

public HashMap() {
    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
}

public HashMap(Map<? extends K, ? extends V> m) {
    this.loadFactor = DEFAULT_LOAD_FACTOR;
    putMapEntries(m, false);
}
```

HashMap有4个构造函数。

hash桶没有在构造函数中初始化，而是在第一次存储键值对的时候进行初始化。 这里重点看下tableSizeFor(initialCapacity)方法，这个方法的作用是，将你传入的initialCapacity做计算，返回一个大于等于initialCapacity 最小的2的幂次方。

所以这个操作保证无论你传入的初始化Hash桶长度参数是多少，最后hash表初始化的长度都是2的幂次方。比如你输入的是6，计算出来结果就是8。

```java
static final int tableSizeFor(int cap) {                                                                      
    int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```



#### 4.put方法

