#### 一、性能测试报告

查看了下阿里云 Redis 的性能测试报告如下，能够达到数十万、百万级别的 QPS（暂时忽略阿里对 Redis 所做的优化），我们从 Redis 的设计和实现来分析一下 Redis 是怎么做的。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghgb3ns5fvj30rr0kdjsx.jpg)

#### 二、Redis 的设计与实现

其实 Redis 主要是通过三个方面来满足这样高效吞吐量的性能需求

- 高效的数据结构
- 多路复用 IO 模型
- 事件机制

##### 2.1 高效的数据结构

Redis 支持的几种高效的数据结构 string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集 合）

以上几种对外暴露的数据结构它们的底层编码方式都是做了不同的优化的，例如string上一章节就有讲到

##### 2.2 多路复用IO模型

假设某一时刻与 Redis 服务器建立了 1 万个长连接，对于阻塞式 IO 的做法就是，对每一条连接都建立一个线程来处理，那么就需要 1万个线程，同时根据我们的经验对于 IO 密集型的操作我们一般设置，线程数 = 2 * CPU 数量 + 1，对于 CPU 密集型的操作一般设置线程 = CPU 数量 + 1，当然各种书籍或者网上也有一个详细的计算公式可以算出更加合适准确的线程数量，但是得到的结果往往是一个比较小的值，像阻塞式 IO 这也动则创建成千上万的线程，系统是无法承载这样的负荷的更加弹不上高效的吞吐量和服务了。

而多路复用 IO 模型的做法是，用一个线程将这一万个建立成功的链接陆续的放入 event_poll，event_poll 会为这一万个长连接注册回调函数，当某一个长连接准备就绪后（建立建立成功、数据读取完成等），就会通过回调函数写入到 event_poll 的就绪队列 rdlist 中，这样这个单线程就可以通过读取 rdlist 获取到需要的数据

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghhgnxsnc5j30my0c474x.jpg)

redis利用epoll来实现IO多路复用，将连接信息和事件放到队列中，依次放到文件事件分派器，事件分派器将事件分发给事件处理器。

事件处理器对不同的事件，进行处理。

##### 2.3 多路复用IO 举个🌰

###### 2.3.1 经营方式一

客户每送来一份快递，小曲就让一个快递员盯着，然后快递员开车去送快递。慢慢的小曲就发现了这种经营方式存在下述问题

- 几十个快递员基本上时间都花在了抢车上了，大部分快递员都处在闲置状态，谁抢到了车，谁就能去送快递
- 随着快递的增多，快递员也越来越多，小曲发现快递店里越来越挤，没办法雇佣新的快递员了
- 快递员之间的协调很花时间

综合上述缺点，小曲痛定思痛，提出了下面的经营方式

###### 2.3.2 **经营方式二**

小曲只雇佣一个快递员。然后呢，客户送来的快递，小曲按**送达地点**标注好，然后**依次**放在一个地方。最后，那个快递员**依次**的去取快递，一次拿一个，然后开着车去送快递，送好了就回来拿下一个快递。在上述比喻中:

- 每个快递员------------------>每个线程
- 每个快递-------------------->每个socket(I/O流)
- 快递的送达地点-------------->socket的不同状态
- 客户送快递请求-------------->来自客户端的请求
- 小曲的经营方式-------------->服务端运行的代码
- 一辆车---------------------->CPU的核数

于是我们有如下结论
1、经营方式一就是传统的并发模型，每个I/O流(快递)都有一个新的线程(快递员)管理。
2、经营方式二就是I/O多路复用。只有单个线程(一个快递员)，通过跟踪每个I/O流的状态(每个快递的送达地点)，来管理多个I/O流。

简单来说，就是。我们的redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/0多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。

##### 2.4 事件机制

redis并没有采用libevent库作为事件机制的底层实现，而是自己对io多路复用进行了封装，即可以采用select、epoll、evport、kqueue作为底层的实现。redis客户端与服务端进行通信时，redis提供了命令事件(也就是文件事件)。另外redis还提供了定时事件，用于对系统实时性要求进行处理，以及处理用户的业务需求。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghhgzbuayqj30pz0t0wfq.jpg)

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghhh1q2ou4j30zk09mwf3.jpg)

1. 首先 redis 服务器运行，监听套接字的 AE_READABLE 事件处于监听的状态下，此时**连接应答处理器**工作，
2. 客户端与 redis 服务器发起建立连接，监听套接字产生 AE_READABLE 事件，当 IO 多路复用程序监听到其准备就绪后，将该事件压入队列中，由文件事件分派器获取队列中的事件交于**连接应答处理器**工作处理，应答客户端建立连接成功，同时将客户端 socket 的 AE_READABLE 事件压入队列由文件事件分派器获取队列中的事件交**命令请求处理器关联**
3. 客户端发送 set key value 请求，客户端 socket 的 AE_READABLE 事件，当 IO 多路复用程序监听到其准备就绪后，将该事件压入队列中，由文件事件分派器获取队列中的事件交于**命令请求处理器关联**处理
4. **命令请求处理器关联**处理完成后，需要响应客户端操作完成，此时将产生 socket 的 AE_WRITEABLE 事件压入队列，由文件事件分派器获取队列中的事件交于**命令恢复处理器**处理，返回操作结果，完成后将解除 AE_WRITEABLE 事件与**命令恢复处理器**的关联

##### 2.5 reactor模式

大体上可以说 Redis 的工作模式是，reactor 模式配合一个队列，用一个 serverAccept 线程来处理建立请求的链接，并且通过 IO 多路复用模型，让内核来监听这些 socket，一旦某些 socket 的读写事件准备就绪后就对应的事件压入队列中，然后 worker 工作，由文件事件分派器从中获取事件交于对应的处理器去执行，当某个事件执行完成后文件事件分派器才会从队列中获取下一个事件进行处理

> 可以类比在 netty 中，我们一般会设置 bossGroup 和 workerGroup 默认情况下 bossGroup 为 1，workerGroup = 2 * cpu 数量，这样可以由多个线程来处理读写就绪的事件，但是其中不能有比较耗时的操作如果有的话需要将其放入线程池中，不然会降低其吐吞量。在 redis 中我们可以看做这二者的值都是 1

https://juejin.im/post/6844903954917097486

https://blog.csdn.net/javaer_lee/article/details/87444386

https://draveness.me/redis-io-multiplexing/

https://juejin.im/post/6844904082176475144

https://blog.csdn.net/u014590757/article/details/79860766

https://juejin.im/post/6844903909073354766

https://zhuanlan.zhihu.com/p/76794272

https://blog.csdn.net/ApeLife/article/details/50926497

