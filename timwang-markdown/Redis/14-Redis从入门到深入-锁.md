##### 1. 锁

###### 1.1 基于特定条件的事务执行

1. 业务场景

	天猫双11热卖过程中，对已经售罄的货物追加补货，4个业务员都有权限进行补货。补货的操作可能是一系列的操作，牵扯到多个连续操作，如何保障不会重复操作?

2. 业务分析

- 多个客户端有可能同时操作同一组数据，并且该数据一旦被操作修改后，将不适用于继续操作
- 在操作之前锁定要操作的数据，一旦发生变化，终止当前操作
 
3. 解决方案

- 对key添加监视锁， 在执行exec前如果key发生了变化， 终止事务执行

```
watch key1 [key2.....]
```

- 取消对所有key的监视

```
unwatch
```

###### 1.2 基于特定条件的事务执行2

1. 业务场景

	天猫双11热卖过程中，对已经售罄的货物追加补货，且补货完成。客户购买热情高涨，3秒内将所有商品购买完毕。本次补货已经将库存全部清空，如何避免最后一件商品不被多人同时购买?【超卖问题】

2. 业务分析

- 使用watch监控一个key有没有改变已经不能解决问题， 此处要监控的是具体数据
- 虽然redis是单线程的，但是多个客户端对同一数据同时进行操作时，如何避免不被同时修改?

3. 解决方案

- 使用setnx设置一个公共锁

```
set nx lock-keyvalue
```

利用set nx命令的返回值特征， 有值则返回设置失败， 无值则返回设置成功
操作完毕通过del操作释放锁

- 对于返回设置成功的，拥有控制权，进行下一步的具体业务操作
- 对于返回设置失败的，不具有控制权，排队或等待，操作完毕通过del操作释放锁

注意：上述解决方案是一种设计概念，依赖规范保障，具有风险性


###### 1.3 基于特定条件的事务执行3

1. 业务场景

依赖分布式锁的机制，某个用户操作时对应客户端宕机，且此时已经获取到锁，如何解决

2. 业务分析

- 由于所操作由用户控制加锁解锁，必定会存在加锁后未解锁的风险
- 需要解锁操作不能仅依赖用户控制，系统级别要给出对应的保底处理方案

3. 解决方案

- 使用expire为锁key添加时间限定，到时候不释放，房企所

```
expire lock-key second
pexpire lock-key milliseconds
```

由于操作通常都是微秒或毫秒级，因此该锁定时间不宜设置过大，具体时间需要业务测试后确认。
	
	- 例如：持有锁的操作最长执行时间127ms，最短执行时间7ms
	- 测试百万次最长执行时间对应命令的最大耗时，测试百万次网络延迟平均耗时
	- 锁时间设定推荐：最大耗时*120%+平均网络延迟*110%
	- 如果业务最大耗时<<网络平均延迟，通常为2个数量级，取其中单个耗时较长即可
