##### 1. 缓存预热

###### 1.1 问题排查

缓存预热就是系统上线后，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！

	- 请求数量较高
	- 主从之间数据吞吐量较大，数据同步操作频度较高

###### 1.2 解决方案

1.日常例行统计数据访问记录，统计访问频度较高的热点数据

2.利用LRU数据删除策略， 构建数据留存队列

    例如：storm与kafka配合

3.将统计结果中的数据分类， 根据级别， red is优先加载级别较高的热点数据

4.利用分布式多服务器同时进行数据读取，提速数据加载过程

实施：

1.使用脚本程序固定触发数据预热过程
2.如果条件允许， 使用了CDN(内容分发网络) ， 效果会更好

###### 1.3 总结

	缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓
存的问题!用户直接查询事先被预热的缓存数据!

##### 2. 缓存穿透
    
###### 2.1 表现

1.系统平稳运行过程中
2.应用服务器流量随时间增量较大
3.Redis服务器命中率随时间逐步降低
4.Redis内存平稳， 内存无压力
5.Redis服务器CPU占用激增
6.数据库服务器压力激增
7.数据库崩溃

###### 2.2 问题排查

1. Redis中大面积出现未命中
2. 出现非正常URL访问

###### 2.3 问题分析

1. 获取的数据在数据库中也不存在，数据库查询未得到对应数据
2. Redis获取到null数据未进行持久化， 直接返回
3. 下次此类数据到达重复上述过程
4. 出现黑客攻击服务器

###### 2.4 解决方案

1. 缓存null

    对查询结果为null的数据进行缓存(长期使用， 定期清理) ， 设定短时限， 例如30-60秒，最高5分钟

2. 白名单策略

- 提前预热各种分类数据id对应的bitmaps， id作为bitmaps的offset， 相当于设置了数据白名单。当加载正常数据时，放行，加载异常数据时直接拦截(效率偏低)

- 使用布隆过滤器(有关布隆过滤器的命中问题对当前状况可以忽略)

3.实施监控

    实时监控redis命中率(业务正常范围时， 通常会有一个波动值) 与null数据的占比

    - 非活动时段波动：通常检测3-5倍，超过5倍纳入重点排查对象
    - 活动时段波动：通常检测10-50倍，超过50倍纳入重点排查对象
    
    根据倍数不同，启动不同的排查流程。然后使用黑名单进行防控(运营)
    
4.key加密
    
    问题出现后， 临时启动防灾业务key， 对key进行业务层传输加密服务， 设定校验程序例如每天随机分配60个加密串， 挑选2到3个， 混淆到页面数据id中， 发现访问key不满足规则，驳回数据访问
    
###### 2.5 总结

缓存击穿访问了不存在的数据，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力，通常此类数据的出现量是一个较低的值，当出现此类情况时以毒攻毒，并及时报警，无论是黑名单还是白名单，都是对整体系统的压力，警报解除时尽快移除


##### 3. 缓存击穿

###### 3.1 问题

缓存击穿表示恶意用户模拟请求很多缓存中不存在的数据，由于缓存中都没有，导致这些请求短时间内直接落在了数据库上，导致数据库异常。这个我们在实际项目就遇到了，有些抢购活动、秒杀活动的接口API被大量的恶意用户刷，导致短时间内数据库宕机了，好在数据库是多主多从的，hold住了。

###### 3.2 解决方案

> 使用互斥锁排队

业界比价普遍的一种做法，即根据key获取value值为空时，锁上，从数据库中load数据后再释放锁。若其它线程获取锁失败，则等待一段时间后重试。这里要注意，分布式环境中要使用分布式锁，单机的话用普通的锁（synchronized、Lock）就够了。

> 布隆过滤器

bloomfilter就类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小，下面先来简单的实现下看看效果，我这里用guava实现的布隆过滤器：


###### 3.3 总结

	缓存击穿就是单个高热数据过期的瞬间， 数据访问量较大， 未命中redis后， 发起了大量对同一数据的数据库访问， 导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行， 配合运行监控测试与即时调整策略， 毕竟单个key的过期监控难度较高，配合雪崩处理策略即可。
    
    
##### 4. 缓存雪崩问题

![595f93df12496d1b0fa7156cb8e6462b.png](https://tva1.sinaimg.cn/large/007S8ZIlgy1gh5wcfmjx3j30fo0a5t8u.jpg)


###### 4.1 问题

缓存在同一时间内大量键过期（失效），接着来的一大波请求瞬间都落在了数据库中导致连接异常。

###### 4.2 表现

> 数据库服务器崩溃(1)
  
    1.系统平稳运行过程中，忽然数据库连接量激增
    2.应用服务器无法及时处理请求
    3.大量408，500错误页面出现
    4.客户反复刷新页面获取数据
    5.数据库崩溃
    6.应用服务器崩溃
    7.重启应用服务器无效
    8.Redis服务器崩溃
    9.Redis集群崩溃
    10.重启数据库后再次被瞬间流量放倒
    
> 数据库服务器崩溃(2)
	
	1.系统平稳运行过程中
	2.数据库连接量瞬间激增
	3.redis服务器无大量key过期
	4.redis内存平稳， 无波动
	5.redis服务器CPU正常
	6.数据库崩溃
    
###### 4.3 问题排查

1.在一个较短的时间内， 缓存中较多的key集中过期
2.此周期内请求访问过期的数据， redis未命中， redis向数据库获取数据
3.数据库同时接收到大量的请求无法及时处理
4.Redis大量请求被积压， 开始出现超时现象
5.数据库流量激增，数据库崩溃
6.重启后仍然面对缓存中无数据可用
7.Redis服务器资源被严重占用， Redis服务器崩溃
8.Redis集群呈现崩塌， 集群瓦解
9.应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃
10.应用服务器， redis， 数据库全部重启， 效果不理想

###### 4.4 解决方案（道）

![2c42c29cc2dbb291f4d281cee8ff60d3.png](https://tva1.sinaimg.cn/large/007S8ZIlgy1gh5wcnk60cj30h70erglx.jpg)


1.更多的页面静态化处理
2.构建多级缓存架构

    Nginx缓存+redis缓存+ehcache缓存

3.检测Mysql严重耗时业务进行优化

    对数据库的瓶颈排查：例如超时查询、耗时较高事务等

4.灾难预警机制

    监控redis服务器性能指标
    - CPU占用、CPU使用率
    - 内存容量
    - 查询平均响应时间
    - 线程数

5.限流、降级

    短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问
    
###### 4.5 解决方案(术)

1.LRU与LFU切换
2.数据有效期策略调整

- 根据业务数据有效期进行分类错峰，A类90分钟，B类80分钟，C类70分钟
- 过期时间使用固定时间+随机值的形式， 稀释集中到期的key的数量

3.超热数据使用永久key
4.定期维护(自动+人工)

    对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时

5.加锁

6. 建立备份缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，A没有读B，并且更新A缓存和B缓存;

7. 缓存时间加上一个随机数

###### 4.6 总结

缓存雪崩就是瞬间过期数据量太大，导致对数据库服务器造成压力。如能够有效避免过期时间集中，可以有效解决雪崩现象的出现
(约40%)，配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。

事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。

事中：本地 ehcache 缓存 + hystrix 限流&降级，避免 MySQL 被打死。

事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。

![02857f9648ac10236df570496cb1122f.png](https://tva1.sinaimg.cn/large/007S8ZIlgy1gh5wcu5qv5j30ma0eqmxp.jpg)
