#### 如何设计一个登录接口

#### 正则表达式

#### TCP和UDP的区别

#### 详细叙述TCP3次握手，TCP和HTTP的区别

#### BIO、NIO、AIO都是什么，有什么区别

#### https相对http都实现了什么加密方式，是对称加密还是非对称加密

#### 单点登录系统怎么做（SSO系统）

##### 1. JWT优点

1. 不需要占用服务器内存开销，session需要保存在服务器，因此会占用服务器内存开销（尽管JWT会有一些计算压力）
2. 可扩展性强：三台服务器组成服务器集群，若session保存在服务器A，session只能保存在其中一台服务器，此时不能访问服务器B/C，而使用JWT就能够验证用户合法性，前后端分离，支持跨域访问

##### 2. JWT缺点

1. token不能保存敏感信息
2. 无法作废已经颁发的token，只能让token自己过期
3. 服务端无法管理客户端的信息
4. 冗余的数据开销

##### 3. JWT 防止令牌泄密导致的系统安全

1. 清除已经泄漏的令牌：在服务器端也保存一份，发现异常的令牌就删除
2. 敏感操作保护，重新验证用户信息
3. 监控请求频率，
4. 客户端环境检查
5. 缩短token有效时间，使用https

#### 分布式事务

#### 怎么设计一个短信验证码系统

- 短信验证码有效期2分钟
- 验证码为6位纯数字
- 每个手机号60秒内只能发送一次短信验证码，且这一规则的校验必须在服务器端执行
- 同一个手机号在同一时间内可以有多个有效的短信验证码
- 保存于服务器端的验证码，至多可被使用3次（无论和请求中的验证码是否匹配），随后立即作废，以防止暴力攻击
- 短信验证码不可直接记录到日志文件
- （可选）发送短信验证码之前，先验证图形验证码是否正确
- （可选）集成第三方API做登录保护

#### 布隆过滤器怎么设计

#### 怎么设计一个短链系统

##### 1. 哈希算法

10进制->16进制，**6 位 62 进制数可表示 568 亿的数**。解决哈希冲突，根据表存储映射关系。长链转短链，去表里面查看记录，如果冲突，然后加一个DUPLICATE再去表里查询（加唯一索引&布隆过滤器）

##### 2. 自增序列算法

维护一个ID自增生成器。ID 生成器为其分配一个 ID，再将其转化为 62 进制，拼接到短链域名后面就得到了最终的短网址（类 uuid & Redis & Snowflake  & Mysql 自增主键），Mysql可设计一个专门的发号表

#### 反转链表

```java
public ListNode reverseList(ListNode head) {
    ListNode prev = null;
    ListNode curr = head;
    while (curr != null) {
        ListNode nextTemp = curr.next;
        curr.next = prev;
        prev = curr;
        curr = nextTemp;
    }
    return prev;
}
```

```java
public ListNode reverseList(ListNode head) {
    if (head == null || head.next == null) return head;
    ListNode p = reverseList(head.next);
    head.next.next = head;
    head.next = null;
    return p;
}
```

#### 跳台阶算法

```java
public int JumpFloor(int target) {
    if(target <= 2){
        return target;
    }else{
        return JumpFloor(target-1) + JumpFloor(target-2);
    }
}
```
**一个台阶总共有n级，如果一次可以跳1级，也可以跳2级......它也可以跳上n级。此时该青蛙跳上一个n级的台阶总共有多少种跳法？**

```
int jumpFloorII(int number) {
		//第一种
		long int sum=0;
		if(number==0) return 1;
		else if(number==1) return 1;
		else if(number==2) return 2;
		else {
				for(int i=number-1; i>=0; i--)
						sum += jumpFloorII(i);
    }
    return sum;
		//第二种做法
		return pow(2, number-1);
}
```

https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/00.01.html

#### 洗牌算法

```
for (int i = n - 1; i >= 0; i--) {
		swap(arr[i], arr[rand() % (i + 1)])
}
```

