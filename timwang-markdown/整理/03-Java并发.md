#### ThreadPoolExecutor

##### 1.1 线程池创建参数

corePoolSize：    线程池维护线程的最少数量 （core : 核心）
maximumPoolSize：  线程池维护线程的最大数量 
keepAliveTime：   线程池维护线程所允许的空闲时间
unit：        线程池维护线程所允许的空闲时间的单位
workQueue：     线程池所使用的缓冲队列
handler：       线程池对拒绝任务的处理策略

##### 1.2 线程池处理优先级

核心线程corePoolSize、任务队列workQueue、最大线程maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。

##### 1.3 拒绝策略

- ThreadPoolExecutor.AbortPolicy()：   抛出java.util.concurrent.RejectedExecutionException异常
- ThreadPoolExecutor.CallerRunsPolicy():   重试添加当前的任务，他会自动重复调用execute()方法
- ThreadPoolExecutor.DiscardOldestPolicy():   抛弃旧的任务
- ThreadPoolExecutor.DiscardPolicy():   抛弃当前的任务

#### 什么是悲观锁和乐观锁

#### 可重入锁和读写锁的区别，哪个效率更高，高并发的场景用哪个更好

#### 在 Java 中 Executor 和 Executors 的区别？

#### 并发编程三要素？

**原子性，有序性，可见性**

1. **原子性:**一个不可再被分割的颗粒。原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。
2. **有序性:** 程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行重排序）
3. **可见性:** 一个县城对共享变量的修改,另一个线程能够立刻看到。

#### 什么是线程组，为什么在 Java 中不推荐使用？

线程组和线程池是两个不同的概念，他们的作用完全不同，前者是为了方便线程的管理，后者是为了管理线程的生命周期，复用线程，减少创建销毁线程的开销。stop、resume、suspend等方法，由于这几个方法会导致线程的安全问题（主要是死锁问题），已经被官方废弃掉了

#### 在 java 中守护线程和本地线程区别？

当我们在Java程序中创建一个线程，它就被称为用户线程。一个守护线程是在后台执行并且不会阻止JVM终止的线程。当没有用户线程在运行的时候，JVM关闭程序并且退出。一个守护线程创建的子线程依然是守护线程。

#### 什么是多线程中的上下文切换？

在上下文切换过程中，CPU会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行。从这个角度来看，上下文切换有点像我们同时阅读几本书，在来回切换书本的同时我们需要记住每本书当前读到的页码。在程序中，上下文切换过程中的“页码”信息是保存在进程控制块（PCB）中的。PCB还经常被称作“切换桢”（switchframe）。“页码”信息会一直保存到CPU的内存中，直到他们被再次使用。

#### Java 中用到的线程调度算法是什么？

有两种调度模型：分时调度模型和抢占式调度模型。
分时调度模型是指让所有的线程轮流获得cpu的使用权,并且平均分配每个线程占用的CPU的时间片这个也比较好理解。
java虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃CPU。

#### 什么是Callable和Future?
Callable接口类似于Runnable，从名字就可以看出来了，

但是Runnable不会返回结果，并且无法抛出返回结果的异常，而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到，也就是说，Future可以拿到异步执行任务的返回值。

可以认为是带有回调的Runnable。

Callable接口代表一段可以调用并返回结果的代码;Future接口表示异步任务，是还没有完成的任务给出的未来结果。所以说Callable用于产生结果，Future用于获取结果。

https://developer.aliyun.com/article/38179

#### **什么是不可变对象，它对写并发应用有什么帮助？**

不可变对象(Immutable Objects)即对象一旦被创建它的状态（对象的数据，也即对象属性值）就不能改变，反之即为可变对象(Mutable Objects)。
不可变对象的类即为不可变类(Immutable Class)。Java平台类库中包含许多不可变类，如String、基本类型的包装类、BigInteger和BigDecimal等。
不可变对象天生是线程安全的。它们的常量（域）是在构造函数中创建的。既然它们的状态无法修改，这些常量永远不会变。

不可变对象永远是线程安全的。
只有满足如下状态，一个对象才是不可变的；
它的状态不能在创建后再被修改；
所有域都是final类型；并且，
它被正确创建（创建期间没有发生this引用的逸出）。

#### **用Java编程一个会导致死锁的程序，你将怎么解决？**

#### **如何在两个线程间共享数据？**

#### **如何避免死锁？**

死锁的发生必须满足以下四个条件：
互斥条件：一个资源每次只能被一个进程使用。
请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。
循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。
避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。

#### **CopyOnWriteArrayList可以用于什么应用场景？**

#### **SynchronizedMap和ConcurrentHashMap有什么区别？**

#### **为什么代码会重排序？**

