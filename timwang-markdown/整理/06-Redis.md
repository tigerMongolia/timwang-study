# Redis和zookeeper做分布式锁的区别，redis为什么适合做分布式锁，它又存在什么问题



# Redis如何实现mq的功能



# Redis实现的消息队列功能和mq有什么区别



# redis单线程为什么执行速度这么快?

（1）：纯内存操作，避免大量访问数据库，减少直接读取磁盘数据，redis将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度快
（2）：单线程操作，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗
（3）：采用了非阻塞I/O多路复用机制

# Redis key 的过期时间和永久有效分别怎么设置？

EXPIRE 和 PERSIST 命令。

# Redis 集群的主从复制模型是怎样的？

（1）全量拷贝， 

	1. slave第一次启动时，连接Master，发送PSYNC命令，
 	2. master会执行bgsave命令来生成rdb文件，期间的所有写命令将被写入缓冲区。
 	3. master bgsave执行完毕，向slave发送rdb文件
 	4. slave收到rdb文件，丢弃所有旧数据，开始载入rdb文件
 	5. rdb文件同步结束之后，slave执行从master缓冲区发送过来的所以写命令。
 	6. 此后 master 每执行一个写命令，就向slave发送相同的写命令。

（2）：增量拷贝 

​	如果出现网络闪断或者命令丢失等异常情况，从节点之前保存了自身已复制的偏移量和主节点的运行ID

# Redis单线程为什么执行速度这么快?

1. 避免了不必要的上下文切换和竞争条件
2. 也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，
3. 不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；

# Redis的过期键删除策略

- **定时删除**：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。

- **惰性删除**：放任过期键不管，每次从键空间中获取键时，检查该键是否过期，如果过期，就删除该键，如果没有过期，就返回该键。

- **定期删除**：每隔一段时间，程序对数据库进行一次检查，删除里面的过期键，至于要删除哪些数据库的哪些过期键，则由算法决定。

# Redis的内存淘汰

- noeviction(默认策略)：对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外）
- allkeys-lru：从所有key中使用LRU算法进行淘汰
- volatile-lru：从设置了过期时间的key中使用LRU算法进行淘汰
- allkeys-random：从所有key中随机淘汰数据
- volatile-random：从设置了过期时间的key中随机淘汰
- volatile-ttl：在设置了过期时间的key中，根据key的过期时间进行淘汰，越早过期的越优先被淘汰

# Redis缓存和MySQL数据一致性方案

1. **采用延时双删策略**

   就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。

   - 先删除缓存；
   - 再写数据库；
   - 休眠500毫秒；
   - 再次删除缓存。

2. **异步更新缓存(基于订阅binlog的同步机制)**

   读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。可以结合使用canal(阿里的一款开源框架)，通过该框架可以对MySQL的binlog进行订阅

