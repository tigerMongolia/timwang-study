# Java内存结构

1. 线程私有的：

- 程序计数器（当前线程所执行的字节码的行号指示器）
- 虚拟机栈（每次方法调用的数据都是通过栈传递的。局部变量表/对象引用/实例方法）
- 本地方法栈（有一个native关键字修饰，而且不存在方法体，这种用native修饰的方法就是本地方法）

2. 线程共享的

- 堆（栈管运行，堆管存储，堆是垃圾收集器管理的主要区域）

- 方法区（存放类的元数据信息，常量和静态变量）

- 直接内存（非运行数据区的一部分）

# Java内存模型

1. 概念

Java内存模型(Java Memory Model，JMM)是java虚拟机规范定义的，工作内存和主内存。Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，

但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝

2. volatie

   - 保证可见性
   - 不保证原子性
   - 禁止指令重排（保证有序性）

3. 总线嗅探机制

   每个处理器通过嗅探在总线上传播的数据来检查自己的缓存值是不是过期了

# 对象的创建过程

类加载检查 -> 分配内存(指针碰撞碰撞/空闲列表) -> 初始化零值 -> 设置对象头 -> 执行 init 方法

分配内存可能存在线程安全问题：

一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性；

另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local AllocationBuffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，

# 对象的内存布局

对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

对象头

- Mark Word：包含一系列的标记位，比如轻量级锁的标记位，偏向锁标记位等等。在32位系统占4字节，在64位系统中占8字节；
- Class Pointer：用来指向对象对应的Class对象（其对应的元数据对象）的内存地址。在32位系统占4字节，在64位系统中占8字节；
- Length：如果是数组对象，还有一个保存数组长度的空间，占4个字节；

# 对象的访问定位

1. Java堆中开辟的句柄池（用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。）
2. 直接指针访问（使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁）

# 内存泄漏和内存溢出

内存溢出：简单地说内存溢出就是指**程序运行过程中申请的内存大于系统能够提供的内存，导致无法申请到足够的内存**，于是就发生了内存溢出。

内存泄漏：内存泄漏指程序运行过程中**分配内存给临时变量，用完之后却没有被GC回收，始终占用着内存**，既不能被使用也不能分配给其他程序，于是就发生了内存泄漏。

# 类加载过程

类加载过程：**加载->连接->初始化**。连接过程又可分为三步:**验证->准备->解析**。

# 类加载器&双亲委派模型介绍

1. 加载器

- BootstrapClassLoader(启动类加载器) 

- ExtensionClassLoader(扩展类加载器)

- AppClassLoader(应用程序类加载器)

- 自定义加载器

2. 双亲委派

每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用 **双亲委派模型** 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的 `loadClass()` 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 `BootstrapClassLoader` 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用启动类加载器 `BootstrapClassLoader` 作为父类加载器。

3. 双亲委派优点

- 可以避免类的重复加载
- 比如我们编写一个称为 `java.lang.Object` 类的话，那么程序运行的时候，系统就会出现多个不同的 `Object` 类。

4. 打破双亲委派

# GC调优策略

1. GC 调优原则；

   多数的 Java 应用不需要在服务器上进行 GC 优化； 多数导致 GC 问题的 Java 应用，都不是因为我们参数设置错误，而是代码问题； 在应用上线之前，先考虑将机器的 JVM 参数设置到最优（最适合）； 减少创建对象的数量； 减少使用全局变量和大对象； GC 优化是到最后不得已才采用的手段； 在实际使用中，分析 GC 情况优化代码比优化 GC 参数要多得多。

2. GC 调优目的；

   将转移到老年代的对象数量降低到最小； 减少 GC 的执行时间。

3. GC 调优策略；

   - 将新对象预留在新生代
   - 大对象进入老年代
   - 合理设置进入老年代对象的年龄
   - 设置稳定的堆大小，堆大小设置有两个参数

# 对象是否存活的判断方法

1. 引用计数方法（互相引用的问题）
2. 可达性分析

即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行

1. 代码调用gc方法通知虚拟机回收
2. 对于标记为垃圾的对象，虚拟机会判断该对象是否覆盖finalize方法或者虚拟机之前是否调用过finalize方法，假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行，否则就把对象放到待回收队列F-Queue中
3. 接下来F-Queue对象进行第二次标记，如果对象的finalize方法中将自己和GC roots引用链（比如类标量）上的引用建立了关联，则完成自我拯救，虚拟机将其移出队列
4. 最后虚拟机会依次触发队列中的对象的finalize方法

# GC Roots的对象分为以下几种

1. 虚拟机栈（栈帧中的本地方法表）中引用的对象（局部变量）
2. 方法区中静态变量所引用的对象（静态变量）
3. 方法区中常量引用的对象
4. 本地方法栈（即native修饰的方法）中JNI引用的对象（JNI是Java虚拟机调用对应的C函数的方式，通过JNI函数也可以创建新的Java对象。且JNI对于对象的局部引用或者全局引用都会把它们指向的对象都标记为不可回收）
5. 已启动的且未终止的Java线程

# 垃圾回收算法

标记清除，复制，标记整理和分代收集算法

### 标记清除

首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。

1. 执行效率不稳定
2. 产生大量的空间碎片

### 标记复制

它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

1. 可用内存缩小为了原来的一半，空间浪费未免太多了

现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代，Appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%。当Survivor空间不足以容纳一次Minor GC之后存活的对

### 标记整理

其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可 回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内 存，如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新 所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用 程序才能进行[

还有一种“和稀泥式”解决方案可以不在内存分配和访问上增加太大额外负担，做法是让虚 拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经 大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。

# 内存泄漏和内存溢出

内存溢出：简单地说内存溢出就是指**程序运行过程中申请的内存大于系统能够提供的内存，导致无法申请到足够的内存**，于是就发生了内存溢出。

内存泄漏：内存泄漏指程序运行过程中**分配内存给临时变量，用完之后却没有被GC回收，始终占用着内存**，既不能被使用也不能分配给其他程序，于是就发生了内存泄漏

# 引用的几种类型

强引用、软引用、弱引用、虚引用

- 强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Objectobj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
- 软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。
- 弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。
- 虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用

# 解决服务器OOM问题

1. top命令
2. jstack命令 jstack pid查看线程的堆栈信息
3. Arthas，CPU 为什么起飞了 thread（redifine/jad）dashboard命令查看总体jvm运行情况，thread 显示jvm里面所有线程信息（类似于jstack）  查看死锁线程命令thread -b。trace 跟踪方法
4. 结合应用报错追踪平台（cat），一些heartbeat的GC info，JVM heap info等

第一步：jps获取进程号 
第二步：jmap -histo pid | head -20 得知有个对象在不断创建 
备注：jmap如果线上服务器堆内存特别大，，会卡死需堆转存（一般会说在测试环境压测，导出转存） 
-XX：+HeapDumpOnOutOfMemoryError或jmap -dumpLformat=b，file=xxx pid 转出文件进行分析 
（arthas没有实现jmap命令）heapdump --live /xxx/xx.hprof导出文件

# 遇到死循环 CPU 飙升怎么解决

1. top命令，看进程占cpu
2. ps -ef|grep <具体进程号>
3. java -jar arthas.jar
4. 指定进程号对应的id
5. 使用dashborad看具体线程
6. trace 类全限定名 方法

# 栈的执行过程

1. 局部变量表

   存放一些局部变量，例如a=1，b=2

1. 操作数栈

   一些变量之前的求和等操作

2. 动态链接

   对应的链接

3. 方法出口

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1giu14f9941j31so0sagqp.jpg)

# OopMap是什么

所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的，

在HotSpot的解决方案里，是使用一组称为OopMap的数据结构来达到这个目的。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查找。

# 什么是三色标记

在遍历对象图的过程中，把访问都的对象按照"是否访问过"这个条件标记成以下三种颜色：

- 白色：表示对象尚未被垃圾回收器访问过。显然，在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。
- 黑色：表示对象已经被垃圾回收器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其它的对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。
- 灰色：表示对象已经被垃圾回收器访问过，但这个对象至少存在一个引用还没有被扫描过。

# 什么时候产生“对象消失“问题

扫描过程中，正在扫描的灰色对象的一个引用被切断了，同时原来引用的对象又与已扫描过的黑色对象建立了引用关系

# 什么时候产生浮动垃圾

# 垃圾收集器

### Serial收集器：

复制算法+标记整理算法，单线程，stop the world暂停用户线程，分别做新生代和老年代的垃圾收集

### ParNew收集器

复制算法+标记整理算法，Serial收集器的多线程并行版本，Serial收集器和ParNew作为新生代的收集器

### Parallel Scavarage收集器

标记复制算法，和ParNew很相似，吞吐量优先收集器，运行用户代码时间/（运行用户代码时间+运行垃圾收集时间）

### SerialOld收集器

复制算法+标记整理算法，Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。

### Parrllel Old收集器

标记整理算法，Parallel Old是Parallel Scavenge收集器的老年代版本

### CMS收集器

“标记-清除”算法实现的收集器，并发低停顿收集，CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。

1）初始标记（CMS initial mark）只是标记一下GCRoots能直接关联到的对象

2）并发标记（CMS concurrent mark）是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程

3）重新标记（CMS remark）修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录

4）并发清除（CMS concurrent sweep）清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，

缺点：

1. CMS收集器对处理器资源非常敏感，虽然不会导致用户线程停顿，但却会因为占用了一部分线程
2. CMS收集器无法处理“浮动垃圾”（Floating Garbage）
3. 收集结束时会有大量空间碎片产生

### G1收集器

它可以面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。

G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。优先处理回收价值收益最大的那些Region

- 初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿
- 并发标记（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。
- 最终标记（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。
- 筛选回收（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。

### Shenandoah收集器

几乎整个工作过程全部都是并发的，只有初始标记、最终标记这些阶段有短暂的停顿，

Shenandoah摒弃了在G1中耗费大量内存和计算资源去维护的记忆集，改用名为“连接矩阵”（ConnectionMatrix）的全局数据结构来记录跨Region的引用关系，降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题（见3.4.4节）的发生概率。

三个最重要的并发阶段（并发标记、并发回收、并发引用更新）

### ZGC收集器

ZGC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器。

小、中和大型Region，大型Region容量不固定（可以动态变化）

# 内存分配策略

1. 对象优先在Eden分配
2. 大对象直接进入老年代
3. 长期存活的对象将进入老年代

# JRE常用工具

### jps

```shell
jps -l
2388 D:\Develop\glassfish\bin\..\modules\admin-cli.jar
2764 com.sun.enterprise.glassfish.bootstrap.ASMain
3788 sun.tools.jps.Jps
```

### jstat

监视虚拟机各种运行状态信息的命令行工具

```shell
jstat -gc 2764 250 20 --假设需要每250毫秒查询一次进程2764垃圾收集状况，一共查询20次，
```

### jinfo

实时查看和调整虚拟机各项参数

```
jinfo [ option ] pid
```

### jmap

jmap（Memory Map for Java）命令用于生成堆转储快照

# Synchronized

### 静态方法上的锁

静态方法是属于“类”，不属于某个实例，是所有对象实例所共享的方法。也就是说如果在静态方法上加入synchronized，那么它获取的就是这个类的锁，**锁住的就是这个类**。

### 实例方法（普通方法）上的锁

实例方法并不是类所独有的，每个对象实例独立拥有它，它并不被对象实例所共享。这也比较能推出，在实例方法上加入synchronized，那么它获取的就是这个累的锁，**锁住的就是这个对象实例**。

### 方法中使用同步代码块

this关键字所代表的意思是该对象实例，换句话说，这种用法synchronized锁住的仍然是对象实例

### synchronized(Demo.class){...}

这种形式等同于抢占获取类锁